# 基础知识

# 数据类型

### 包装类型

##### 数值比较

- 包装类型在 -128 ~ 127之间时，使用`==`或`equals`比较都是`true`，因为在此范围内直接中缓存中取值；超过此范围只能用`equals`；**故包装类型的数值比较直接用`equals`**。

```java
Long l1 = 123456L;
Long l2 = 123456L;
System.out.println(l1.equals(l2));
System.out.println(l1 == l2);

true
false
    
Serializable l4 = 123456L;
Serializable l5 = 123456L;
System.out.println(l4.equals(l5));
System.out.println(l4 == l5);

true
false
```

- 包装类型与基本数据类型比较时，会自动拆包为基本数据类型，故用`==`即可

```java
System.out.println(l1.equals(123456L));
System.out.println(l1 == 123456L);
System.out.println(l1 == 123456);

true
true
true
```

> [!NOTE]
>
> 包装类型如果为null时，自动拆包会报空指针异常

### 实例类型判断

```java
PackageData pd = new PackageData();
PackageData pd1 = null;
byte[] b = new byte[0];
byte[] b1 = null;

System.out.println(pd instanceof PackageData);
System.out.println(pd1 instanceof PackageData);
System.out.println(b instanceof byte[]);
System.out.println(b1 instanceof byte[]);
```

> [!TIP]
>
> 值为`null`时，`instanceof`返回`false`

# 枚举

```java
enum EnumTest11 {
    DOG,
    TIGER
}

@Getter
enum EnumTest12 {
    DOG(2),
    TIGER(3);

    private int value;

    EnumTest12(int value) {
        this.value = value;
    }
}
```

```java
System.out.println(EnumTest11.TIGER.name());
System.out.println(EnumTest11.TIGER.toString());
System.out.println(EnumTest12.TIGER.name());
System.out.println(EnumTest12.TIGER.toString());
System.out.println(EnumTest12.TIGER.getValue());
TIGER
TIGER
TIGER
TIGER
3
```

`name`和`toString`方法的区别：

- `name()`是`final`的，返回枚举名称
- `toString()`默认返回`name()`

> [枚举：如何正确使用name（）和toString（）方法_dnc8371的博客-CSDN博客](https://blog.csdn.net/dnc8371/article/details/106702197)
>
> [Enum: How to use name() and toString() methods correctly - Java Code Geeks - 2023](https://www.javacodegeeks.com/2017/09/enum-use-name-tostring-methods-correctly.html)

> [!NOTE]
>
> 当枚举使用`value`属性时，使用 fastjson2 序列化应注意：防止将枚举字段序列化为`value`，参看[java/fastjson - fastjson2 序列化枚举问题](java/fastjson.md#fastjson2序列化枚举问题)



# List

##### 排序

```java
List<Person> test2 = new ArrayList<>();
test2.add(new Person("alex", 19, null));
test2.add(new Person("alice", 18, null));

// 两者任选其一，数字小则顺序不变，数字大交换顺序，即升序
test2.sort((a, b) -> a.age - b.age);
test2.sort(Comparator.comparingInt(a -> a.age));
print(test2);
```

 
