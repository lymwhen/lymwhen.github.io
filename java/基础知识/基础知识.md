# 基础知识

# 数据类型

### 包装类型

##### 数值比较

- 包装类型在 -128 ~ 127之间时，使用`==`或`equals`比较都是`true`，因为在此范围内直接中缓存中取值；超过此范围只能用`equals`；**故包装类型的数值比较直接用`equals`**。

```java
Long l1 = 123456L;
Long l2 = 123456L;
System.out.println(l1.equals(l2));
System.out.println(l1 == l2);

true
false
    
Serializable l4 = 123456L;
Serializable l5 = 123456L;
System.out.println(l4.equals(l5));
System.out.println(l4 == l5);

true
false
```

- 包装类型与基本数据类型比较时，会自动拆包为基本数据类型，故用`==`即可

```java
System.out.println(l1.equals(123456L));
System.out.println(l1 == 123456L);
System.out.println(l1 == 123456);

true
true
true
```

> [!NOTE]
>
> 包装类型如果为null时，自动拆包会报空指针异常

# 枚举

```java
enum EnumTest11 {
    DOG,
    TIGER
}

@Getter
enum EnumTest12 {
    DOG(2),
    TIGER(3);

    private int value;

    EnumTest12(int value) {
        this.value = value;
    }
}
```

```java
System.out.println(EnumTest11.TIGER.name());
System.out.println(EnumTest11.TIGER.toString());
System.out.println(EnumTest12.TIGER.name());
System.out.println(EnumTest12.TIGER.toString());
System.out.println(EnumTest12.TIGER.getValue());
TIGER
TIGER
TIGER
TIGER
3
```

`name`和`toString`方法的区别：

- `name()`是`final`的，返回枚举名称
- `toString()`默认返回`name()`

> [枚举：如何正确使用name（）和toString（）方法_dnc8371的博客-CSDN博客](https://blog.csdn.net/dnc8371/article/details/106702197)
>
> [Enum: How to use name() and toString() methods correctly - Java Code Geeks - 2023](https://www.javacodegeeks.com/2017/09/enum-use-name-tostring-methods-correctly.html)

### fastjson2 问题

fastjson2 有的版本处理枚举时，会将枚举处理为自定义的“value”，如果需要使用名称，需要配置`JSONWriter.Feature`使用`toString方法`：`JSONWriter.Feature.WriteEnumUsingToStrings`

```java
// 设置fastjson2 features
JSON.config(
    JSONWriter.Feature.WriteMapNullValue, 
    JSONWriter.Feature.WriteNullNumberAsZero, 
    JSONWriter.Feature.WriteNullStringAsEmpty,
    JSONWriter.Feature.WriteNullListAsEmpty, 
    JSONWriter.Feature.WriteNullBooleanAsFalse, 
    JSONWriter.Feature.WriteEnumUsingToString
);
```



# 常用代码

##### java8 Streams map()

Streams map() 可以将列表对象转换为新的对象，并作为新列表返回，**新列表中的元素为map()方法处理后的返回值**。

```java
List<String> xxs = new ArrayList<>();
xxs.add("test1");
xxs.add("test2");
xxs.add("Test3");
print(xxs);

List<String> xxsn = xxs.stream().map(x -> x + "A").collect(Collectors.toList());
print(xxsn);

[test1, test2, Test3]
[test1A, test2A, Test3A]
```

```java
List<Person> test2 = new ArrayList<>();
test2.add(new Person("alice", 18, null));
test2.add(new Person("alex", 19, null));
print(test2);
List<Person> test3 = test2.stream().map(x -> {
    x.age++;
    return x;
}).collect(Collectors.toList());
print(test2);
print(test3);

List<String> test4 = test2.stream().map(x -> x.name).collect(Collectors.toList());
print(test4);

[{"age":18,"name":"alice"},{"age":19,"name":"alex"}]
[{"age":19,"name":"alice"},{"age":20,"name":"alex"}]
[{"age":19,"name":"alice"},{"age":20,"name":"alex"}]
["alice","alex"]
```

##### 排序

```java
List<Person> test2 = new ArrayList<>();
test2.add(new Person("alex", 19, null));
test2.add(new Person("alice", 18, null));

// 两者任选其一，数字小则顺序不变，数字大交换顺序，即升序
test2.sort((a, b) -> a.age - b.age);
test2.sort(Comparator.comparingInt(a -> a.age));
print(test2);
```

 
