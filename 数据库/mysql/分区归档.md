# 分区归档

```sql
-- 建表时设置分区
CREATE TABLE orders (
    id INT NOT NULL AUTO_INCREMENT,
    order_date DATE NOT NULL,
    amount DECIMAL(10,2),
    PRIMARY KEY (id, order_date)
) PARTITION BY RANGE (TO_DAYS(order_date)) (
    PARTITION p20240101 VALUES LESS THAN (TO_DAYS('2024-01-02')),
    PARTITION p20240102 VALUES LESS THAN (TO_DAYS('2024-01-03')),
    PARTITION p20240103 VALUES LESS THAN (TO_DAYS('2024-01-04'))
);

-- 先建表，后设置分区
CREATE TABLE orders (
    id INT NOT NULL AUTO_INCREMENT,
    order_date DATE NOT NULL,
    amount DECIMAL(10,2),
    PRIMARY KEY (id, order_date)
);

ALTER TABLE orders PARTITION BY RANGE (TO_DAYS(order_date)) (
    PARTITION p20240101 VALUES LESS THAN (TO_DAYS('2024-01-02')),
    PARTITION p20240102 VALUES LESS THAN (TO_DAYS('2024-01-03')),
    PARTITION p20240103 VALUES LESS THAN (TO_DAYS('2024-01-04'))
);

-- 添加分区
ALTER TABLE orders ADD PARTITION (
    PARTITION p20240104 VALUES LESS THAN (TO_DAYS('2024-01-05')))
```

# 语法定义

### 1. **LIST 分区** - 离散值列表

使用 `VALUES IN` 定义离散值集合，适合枚举类型的数据：

```sql
CREATE TABLE employees (
    id INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY LIST(store_id) (
    PARTITION pNorth VALUES IN (3, 5, 6, 9, 17),
    PARTITION pEast VALUES IN (1, 2, 10, 11, 19),
    PARTITION pWest VALUES IN (4, 12, 13, 14, 18),
    PARTITION pCentral VALUES IN (7, 8, 15, 16)
);
```

### 2. **HASH 分区** - 哈希散列

使用 `PARTITIONS` 关键字指定分区数，MySQL 自动计算哈希值：

```sql
-- 常规 HASH 分区
CREATE TABLE orders (
    order_id INT NOT NULL,
    order_date DATE NOT NULL
)
PARTITION BY HASH(YEAR(order_date))
PARTITIONS 4;

-- 线性 HASH 分区（LINEAR HASH）
CREATE TABLE orders_linear (
    order_id INT NOT NULL,
    order_date DATE NOT NULL
)
PARTITION BY LINEAR HASH(YEAR(order_date))
PARTITIONS 4;
```

### 3. **KEY 分区** - 类似 HASH，但使用 MySQL 内部哈希函数

```sql
CREATE TABLE customers (
    id INT NOT NULL,
    name VARCHAR(100)
)
PARTITION BY KEY(id)
PARTITIONS 4;

-- 线性 KEY 分区
PARTITION BY LINEAR KEY(id)
PARTITIONS 4;
```

### 4. **COLUMNS 分区**（MySQL 5.5+）

支持多列和多种数据类型的范围/List 分区：

```sql
-- RANGE COLUMNS（多列范围）
CREATE TABLE range_columns_example (
    a INT,
    b INT
)
PARTITION BY RANGE COLUMNS(a, b) (
    PARTITION p0 VALUES LESS THAN (10, 5),
    PARTITION p1 VALUES LESS THAN (10, 10),
    PARTITION p2 VALUES LESS THAN (MAXVALUE, MAXVALUE)
);

-- LIST COLUMNS（多列离散值）
CREATE TABLE list_columns_example (
    a INT,
    b INT
)
PARTITION BY LIST COLUMNS(a, b) (
    PARTITION p0 VALUES IN ((0, 0), (NULL, NULL)),
    PARTITION p1 VALUES IN ((1, 1), (1, 2)),
    PARTITION p2 VALUES IN ((2, 1), (2, 2))
);
```

### 5. **子分区（Subpartitioning）** - 复合分区

在分区基础上再进行二次分区：

```sql
CREATE TABLE ts (
    id INT,
    purchased DATE
)
PARTITION BY RANGE(YEAR(purchased))
SUBPARTITION BY HASH(TO_DAYS(purchased))
SUBPARTITIONS 2 (
    PARTITION p0 VALUES LESS THAN (1990),
    PARTITION p1 VALUES LESS THAN (2000),
    PARTITION p2 VALUES LESS THAN MAXVALUE
);
```



| 分区类型    | 关键字                    | 适用场景                   |
| :---------- | :------------------------ | :------------------------- |
| RANGE   | `LESS THAN`               | 连续范围（日期、ID 区间）  |
| LIST    | `VALUES IN`               | 离散枚举值（地区、状态码） |
| HASH    | `PARTITIONS`              | 均匀分布，无需指定范围     |
| KEY     | `PARTITIONS`              | 类似 HASH，使用内置函数    |
| COLUMNS | `LESS THAN` / `VALUES IN` | 多列分区，支持非整数类型   |

选择分区方式时，主要考虑：

- **RANGE**：时间序列数据、按日期归档
- **LIST**：固定分类（如省份、部门）
- **HASH/KEY**：需要均匀分布，避免热点
- **COLUMNS**：需要多列组合分区或非整数类型分区

# 生产方案

### 兜底分区

```sql
CREATE TABLE orders (
    order_id BIGINT,
    order_time DATETIME,
    -- 必须包含分区键
    PRIMARY KEY (order_id, order_time)
) PARTITION BY RANGE (TO_DAYS(order_time)) (
    PARTITION p202401 VALUES LESS THAN (TO_DAYS('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (TO_DAYS('2024-03-01')),
    PARTITION p_future VALUES LESS THAN MAXVALUE  -- 兜底
);

-- 配合监控告警：当 p_future 出现数据时，说明需要添加新分区了！
```

### 定期自动创建分区

```sql
-- 创建事件，每月自动添加分区
DELIMITER //
CREATE EVENT auto_add_partition
ON SCHEDULE EVERY 1 MONTH
DO
BEGIN
    SET @next_month = DATE_FORMAT(DATE_ADD(NOW(), INTERVAL 2 MONTH), '%Y%m');
    SET @sql = CONCAT(
        'ALTER TABLE orders ADD PARTITION (
            PARTITION p', @next_month, 
        ' VALUES LESS THAN (TO_DAYS("', 
        DATE_FORMAT(DATE_ADD(NOW(), INTERVAL 3 MONTH), '%Y-%m-01'), 
        '")))'
    );
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END //
DELIMITER ;
```



# 测试流程

建表、插入测试数据、创建分区（Range方式，按天，不使用兜底分区）、查看各分区数据、分区后插入测试数据、尝试插入无法匹配分区的数据、查看各分区数据、通过删除分区方式删除数据、将最老的分区归档（分区移动到`表名_日期`命名的表）、将归档的表通过分区方式拉回原表

### 建表

```sql
mysql> use dev
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed

mysql> DROP TABLE IF EXISTS orders;
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> DROP TABLE IF EXISTS orders_20240102;
Query OK, 0 rows affected, 1 warning (0.01 sec)

mysql> CREATE TABLE orders (
           id INT NOT NULL AUTO_INCREMENT,
           order_date DATE NOT NULL,
           amount DECIMAL(10,2),
           PRIMARY KEY (id, order_date)
       );
Query OK, 0 rows affected (0.03 sec)
```

### 插入测试数据（分区前）

```sql
mysql> INSERT INTO orders (order_date, amount) VALUES
       ('2024-01-01', 100.00),
       ('2024-01-02', 200.00),
       ('2024-01-03', 300.00);
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> select * from orders;
+----+------------+--------+
| id | order_date | amount |
+----+------------+--------+
|  1 | 2024-01-01 | 100.00 |
|  2 | 2024-01-02 | 200.00 |
|  3 | 2024-01-03 | 300.00 |
+----+------------+--------+
3 rows in set (0.00 sec)
```

### 创建分区（Range方式，按天，不使用兜底分区）

- 已有数据会被自动进入对应分区
- 如果不使用兜底分区，则分区设置应要能覆盖所有数据，否则会报错`ERROR 1526 (HY000): Table has no partition for value 739253`

```sql
mysql> ALTER TABLE orders PARTITION BY RANGE (TO_DAYS(order_date)) (
           PARTITION p20240101 VALUES LESS THAN (TO_DAYS('2024-01-02')),
           PARTITION p20240102 VALUES LESS THAN (TO_DAYS('2024-01-03')),
           PARTITION p20240103 VALUES LESS THAN (TO_DAYS('2024-01-04'))
       );
Query OK, 3 rows affected (0.17 sec)
Records: 3  Duplicates: 0  Warnings: 0

# 查看各分区数据
mysql> SELECT
           PARTITION_NAME,
           TABLE_ROWS
       FROM INFORMATION_SCHEMA.PARTITIONS
       WHERE TABLE_NAME = 'orders';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p20240101      |          1 |
| p20240102      |          1 |
| p20240103      |          1 |
+----------------+------------+
3 rows in set (0.01 sec)

mysql> SELECT * FROM orders PARTITION (p20240101);
+----+------------+--------+
| id | order_date | amount |
+----+------------+--------+
|  1 | 2024-01-01 | 100.00 |
+----+------------+--------+
1 row in set (0.00 sec)

mysql> SELECT * FROM orders PARTITION (p20240102);
+----+------------+--------+
| id | order_date | amount |
+----+------------+--------+
|  2 | 2024-01-02 | 200.00 |
+----+------------+--------+
1 row in set (0.00 sec)

mysql> SELECT * FROM orders PARTITION (p20240103);
+----+------------+--------+
| id | order_date | amount |
+----+------------+--------+
|  3 | 2024-01-03 | 300.00 |
+----+------------+--------+
1 row in set (0.00 sec)
```

### 分区后插入测试数据

- 新插入的数据会自动进入对应分区
- 如果没有对应分区，且没有兜底分区，插入会报错没有对应分区

```sql
mysql> INSERT INTO orders (order_date, amount) VALUES
       ('2024-01-01', 150.00),
       ('2024-01-02', 250.00),
       ('2024-01-03', 350.00);
Query OK, 3 rows affected (0.02 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> INSERT INTO orders (order_date, amount) VALUES ('2024-01-04', 400.00);
ERROR 1526 (HY000): Table has no partition for value 739254

mysql> SELECT
           PARTITION_NAME,
           TABLE_ROWS
       FROM INFORMATION_SCHEMA.PARTITIONS
       WHERE TABLE_NAME = 'orders';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p20240101      |          2 |
| p20240102      |          2 |
| p20240103      |          2 |
+----------------+------------+
3 rows in set (0.00 sec)

mysql> select * from orders;
+----+------------+--------+
| id | order_date | amount |
+----+------------+--------+
|  1 | 2024-01-01 | 100.00 |
|  2 | 2024-01-02 | 200.00 |
|  3 | 2024-01-03 | 300.00 |
|  4 | 2024-01-01 | 150.00 |
|  5 | 2024-01-02 | 250.00 |
|  6 | 2024-01-03 | 350.00 |
+----+------------+--------+
3 rows in set (0.00 sec)
```

### 通过删除分区方式删除数据

- `DROP PARTITION`删除分区时，分区中的数据也会被删除

```sql
mysql> ALTER TABLE orders DROP PARTITION p20240101;
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

# 删除分区后，分区信息中的table_rows统计不对，需要执行analyze
mysql> SELECT
           PARTITION_NAME,
           TABLE_ROWS
       FROM INFORMATION_SCHEMA.PARTITIONS
       WHERE TABLE_NAME = 'orders';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p20240102      |          1 |
| p20240103      |          1 |
+----------------+------------+
2 rows in set (0.01 sec)

mysql> ANALYZE TABLE orders;
+-----------------------+---------+----------+----------+
| Table                 | Op      | Msg_type | Msg_text |
+-----------------------+---------+----------+----------+
| apollo_rt6_dev.orders | analyze | status   | OK       |
+-----------------------+---------+----------+----------+
1 row in set (0.02 sec)

mysql> SELECT            PARTITION_NAME,            TABLE_ROWS        FROM INFORMATION_SCHEMA.PARTITIONS        WHERE TABLE_NAME = 'orders';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p20240102      |          2 |
| p20240103      |          2 |
+----------------+------------+
2 rows in set (0.00 sec)

mysql> select * from orders;
+----+------------+--------+
| id | order_date | amount |
+----+------------+--------+
|  2 | 2024-01-02 | 200.00 |
|  5 | 2024-01-02 | 250.00 |
|  3 | 2024-01-03 | 300.00 |
|  6 | 2024-01-03 | 350.00 |
+----+------------+--------+
4 rows in set (0.00 sec)
```

### 将最老的分区归档

将最老的分区归档（分区移动到`表名_日期`命名的表）

- `CREATE TABLE xxx LIKE xxx`，会复制除数据外的其他信息，包括字符集、排序规则、表结构、主键约束、分区、索引等
- `REMOVE PARTITIONING`不会删除分区中的数据

```sql
mysql> CREATE TABLE orders_20240102 LIKE orders;
Query OK, 0 rows affected (0.05 sec)

mysql> ALTER TABLE orders_20240102 REMOVE PARTITIONING;
Query OK, 0 rows affected (0.08 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

交换分区

- 交换语句结构为 A 表 A1 分区与 B 表交换，即 A1 分区与 B 整个表互换：A1 ↔ B

> [!NOTE]
>
> - 交换时 **A1、B 都允许有数据**，表现为两者数据互换：
>
>   - 如果数据归档之后想换回来，再次执行相同的命令即可
>
>   - 如果 B 表中有不符合 A1 分区规则的数据，将会报错
>
> - 交换时 **B 表中不允许有分区**，不然会报错：
>
> ```sql
> # 在归档表中创建分区
> mysql> ALTER TABLE orders_20240102 PARTITION BY RANGE (TO_DAYS(order_date)) (
>      PARTITION p20240101 VALUES LESS THAN (TO_DAYS('2024-01-02')),
>      PARTITION p20240102 VALUES LESS THAN (TO_DAYS('2024-01-03')),
>      PARTITION p20240103 VALUES LESS THAN (TO_DAYS('2024-01-04'))
>  );
> Query OK, 0 rows affected (0.17 sec)
> Records: 0  Duplicates: 0  Warnings: 0
> 
> mysql> ALTER TABLE orders EXCHANGE PARTITION p20240102 WITH TABLE orders_20240102;
> ERROR 1732 (HY000): Table to exchange with partition is partitioned: 'orders_20240102'
> ```
>





```sql
# 交换
mysql> ALTER TABLE orders EXCHANGE PARTITION p20240102 WITH TABLE orders_20240102;
Query OK, 0 rows affected (0.04 sec)

mysql> select * from orders;
+----+------------+--------+
| id | order_date | amount |
+----+------------+--------+
|  3 | 2024-01-03 | 300.00 |
|  6 | 2024-01-03 | 350.00 |
+----+------------+--------+
2 rows in set (0.00 sec)

mysql> select * from orders_20240102;
+----+------------+--------+
| id | order_date | amount |
+----+------------+--------+
|  2 | 2024-01-02 | 200.00 |
|  5 | 2024-01-02 | 250.00 |
+----+------------+--------+
2 rows in set (0.00 sec)

# 交换回来
mysql> ALTER TABLE orders EXCHANGE PARTITION p20240102 WITH TABLE orders_20240102;
Query OK, 0 rows affected (0.04 sec)

mysql> select * from orders;
+----+------------+--------+
| id | order_date | amount |
+----+------------+--------+
|  2 | 2024-01-02 | 200.00 |
|  5 | 2024-01-02 | 250.00 |
|  3 | 2024-01-03 | 300.00 |
|  6 | 2024-01-03 | 350.00 |
+----+------------+--------+
4 rows in set (0.00 sec)

mysql> SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS  WHERE TABLE_NAME = 'orders_20240102';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| NULL           |          0 |
+----------------+------------+
1 row in set (0.00 sec)

mysql> select * from orders_20240102;
Empty set (0.00 sec)
```

